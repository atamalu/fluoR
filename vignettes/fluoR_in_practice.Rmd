---
title: "Using fluoR in practice"
author: "Andrew Tamalunas"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The "Example" vignette gives examples of using the `fluoR` package. This document is meant to explain when using each function would be appropriate in your exploration and analysis of GCaMP data.

## format_data

`format_data` should be used before any other function. This ensures that the rest of the dataframe-based functions from fluoR will work correctly with your dataset.

#### 1. Wide data

If you take a look at the included `GCaMP` dataset, you will see that it was exported from Matlab in wide format. There is one row per trial, rather than one column per trial. 

```{r}
library(fluoR)
print('Before')
nrow(GCaMP); ncol(GCaMP)
```

We can fix this using `format_data`.

```{r}
df <- format_data(GCaMP)

print('After')

nrow(df)
ncol(df)
```

#### 2. Column labeling

If the user were to simply transpose the `GCaMP` dataset, the result would be another matrix with the correct row/column format but no column names. 

```{r}
GCaMP.t <- t(GCaMP)

print('Before')

nrow(GCaMP.t)
ncol(GCaMP.t)
colnames(GCaMP.t)
```

This would still work with the `fluoR` package, but it could be problematic in exploratory situations. Mentally adding 1 to the index every time you call a trial (time is in the first column) results in unnecessary potential for a simple mistake. To fix this, `fluoR` simply labels each trial column as "Trial[n]", and the time column as "Time".

```{r}
df <- format_data(GCaMP.t)

nrow(df); ncol(df)
colnames(GCaMP.t)
```

## inflect_points

`inflect_points` uses derivatives to determine peaks and valleys in data. A vector of numbers that is the same length as the input is returned. This output format is catered to use in functions that require multiple same-length vectors as input.

```{r}
```

This function is also useful when constructing algorithms that are not included in the `fluoR` package.

```{r}
```

## find_peaks

`find_peaks` uses an algorithm that starts at an inflection point and works its way left and right for `n.points`. If there are `n.points` increasing or decreasing on each side, it will be labeled a peak or valley. 

This is especially useful for avoiding false positives that may occur when using only inflection points to classify peaks. In this case, a single-point increase in activity would be labeled as a peak.

So, to avoid false positives, we may formally decide on the criteria:

* Inflection points represent peaks if 5 data points area decreasing on each side of it

```{r}
pks <- find_peaks(xvals = df$Trial1,
                  n.points = 8)
print(pks)
```

This returns the row indices that the algorithm found `length(pks)` peaks at.

```{r}
plot(df$Trial1, type = 'l',
     xlab = 'Time', ylab = 'Intensity')

for(i in 1:length(pks)){
  pk <- pks[[i]]
  points(x = pk, y = df[pk,'Trial1'], col = 'red')
}
```

## percent_change

`percent_change` is straightforward. This uses the below formula to transform each value {xvals} into its change from a baseline value {base.val}

$$
\% \ change = \frac{(new \ value) - (old \ value)}{\mid  old \ value \mid  } \ 
\cdot 100\%
$$
or, for our purposes

$$
\% \ change \ from \ baseline = \frac{(value) - (base \ value)}{\mid  base \ value \mid  } \ 
\cdot 100\%
$$

The best baseline value to scale at depends on your hypothesis. For example: if wanted to measure activity around a post- stimulus onset relative to pre-stimulus baseline, we could use

```{r}

```